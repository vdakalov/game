(function() {
  var each, getInstance, parseOptions;

  each = function(obj, context, handler) {
    return obj.forEach((handler || context).bind(context || this));
  };

  window.scope = {
    services: {},
    controllers: []
  };

  parseOptions = function(options) {
    var dependencies, name, _ref;
    _ref = options.split(/\s*:\s*/), name = _ref[0], dependencies = _ref[1];
    return [name, dependencies ? dependencies.split(/\s*,\s*/) : []];
  };

  getInstance = function(serviceName) {
    var deps, service;
    if (serviceName in scope.services) {
      service = scope.services[serviceName];
      deps = [];
      each(service.services, function(serviceName) {
        return deps.push(getInstance(serviceName));
      });
      return service.factory.apply(window, deps);
    }
  };


  /* REGISTER CONTROLLERS */

  window.controller = function(options, handler) {
    var name, services, _ref;
    _ref = parseOptions(options), name = _ref[0], services = _ref[1];
    return scope.controllers.push({
      name: name,
      services: services,
      handler: handler
    });
  };


  /* REGISTER SERVICES */

  window.service = function(options, factory) {
    var name, services, _ref;
    _ref = parseOptions(options), name = _ref[0], services = _ref[1];
    return scope["services"][name] = {
      services: services,
      factory: typeof factory === "function" ? factory : function() {
        return factory;
      }
    };
  };


  /* BOOTSTRAP */

  window.onload = function() {
    return each(scope.controllers, function(controller) {
      var deps;
      deps = [];
      each(controller.services, function(serviceName) {
        return deps.push(getInstance(serviceName));
      });
      return controller.handler.apply(window, deps);
    });
  };

}).call(this);
(function() {
  controller("main:el,MT16S2H2FLA,CharacterGenerator,Symbols,GraphicGenerator,GraphicObjects,Game", function(el, MT16S2H2FLA, CharacterGenerator, Symbols, GraphicGenerator, GraphicObjects, Game) {
    var cg, game, gg, lcg, lcgm, lcs, mountGame, mountGraphic, mountSymbols, symbols;
    symbols = {
      A: new Symbols.Hexadecimal(5, "22a318fe31"),
      B: new Symbols.Hexadecimal(5, "f463e8c63e"),
      C: new Symbols.Hexadecimal(5, "746108422e"),
      DOT: new Symbols.Hexadecimal(2, "f"),
      SPACE: new Symbols.ControlSymbol(CharacterGenerator.CONTROL_SYMBOL_INCREMENT),
      NEWLINE: new Symbols.ControlSymbol(CharacterGenerator.CONTROL_SYMBOL_NEWLINE)
    };

    /* GRAPHIC DISPLAY */
    mountGraphic = el.get("#graphic");
    lcg = new MT16S2H2FLA(mountGraphic);
    gg = new GraphicGenerator(lcg);
    gg.render(new GraphicObjects.Circle([7, 7, 5]));

    /* SYMBOLS DISPLAY */
    mountSymbols = el.get("#symbols");
    lcs = new MT16S2H2FLA(mountSymbols);
    cg = new CharacterGenerator(lcs, 16, 2);
    cg.printSymbol(symbols.A);
    cg.printSymbol(symbols.SPACE);
    cg.printSymbol(symbols.B);
    cg.printSymbol(symbols.NEWLINE);
    cg.printSymbol(symbols.C);

    /* GAME DISPLAY */
    mountGame = el.get("#game");
    lcgm = new MT16S2H2FLA(mountGame);
    game = new Game(lcgm);
    game.addWall(new GraphicObjects.Line([[1, 1], [50, 1]]));
    game.addWall(new GraphicObjects.Line([[50, 1], [50, 16]]));
    game.addWall(new GraphicObjects.Line([[1, 16], [50, 16]]));
    game.addWall(new GraphicObjects.Line([[1, 1], [1, 16]]));
    game.addWall(new GraphicObjects.Line([[22, 16], [22, 6]]));
    game.init();
    game.start();
    return window.game = game;
  });

}).call(this);
(function() {
  service("el:utils", function(utils) {
    return {
      isEl: function(el) {
        return el instanceof HTMLElement;
      },
      get: document.querySelector.bind(document),
      getAll: document.querySelectorAll.bind(document),
      make: function(tagName, attrs, body, parent) {
        var el;
        el = this.isEl(tagName) ? tagName : document.createElement(tagName);
        utils.each(attrs || {}, function(value, key) {
          return el.setAttribute(key, value);
        });
        if (typeof body === "string") {
          el.innerHTML = body;
        }
        if (this.isEl(parent)) {
          parent.appendChild(el);
        }
        return el;
      },
      style: function(el, style, value) {
        if (arguments.length === 3) {
          el.style[style] = value;
        }
        return el.style[style];
      },
      styles: function(el, rules) {
        return utils.each(rules, this, function(value, rule) {
          return el.style[rule] = value;
        });
      },
      "class": function(el, className, turn) {
        new RegExp(className).test(el.className);
        if (arguments.length > 2) {
          el.className = utils.trim(el.className.replace(new RegExp("(^|\s)" + className + "($|\s)"), " "));
          if (turn === true) {
            return el.className = utils.trim("" + el.className + " " + className);
          }
        } else {
          return new RegExp(className).test(el.className);
        }
      }
    };
  });

}).call(this);
(function() {
  service("utils", {
    each: function(obj, context, handler) {
      var index, item, name, _ref, _ref1;
      index = 0;
      if (arguments.length === 1) {
        _ref = [obj, this, null], handler = _ref[0], obj = _ref[1], context = _ref[2];
      }
      if (arguments.length === 2) {
        _ref1 = [context, null], handler = _ref1[0], context = _ref1[1];
      }
      if (typeof obj === 'object' && obj !== null && typeof handler === 'function') {
        for (name in obj) {
          item = obj[name];
          if (obj.hasOwnProperty(name) && (name !== 'length' || !(obj instanceof Array))) {
            if (context) {
              handler.call(context, item, name, index++);
            } else {
              handler(item, name, index++);
            }
          }
        }
      }
      return obj;
    },
    grep: function(obj, context, handler) {
      var isArr, list, _ref, _ref1;
      if (arguments.length === 1) {
        _ref = [obj, this, null], handler = _ref[0], obj = _ref[1], context = _ref[2];
      }
      if (arguments.length === 2) {
        _ref1 = [context, null], handler = _ref1[0], context = _ref1[1];
      }
      isArr = obj instanceof Array;
      list = isArr ? [] : {};
      this.each(obj, context, function(value, key, index) {
        if (handler.call(context, value, key, index) !== false) {
          if (isArr) {
            return list.push(value);
          } else {
            return list[key] = value;
          }
        }
      });
      return list;
    },
    collect: function(obj, context, handler) {
      var isArr, list, _ref, _ref1;
      if (arguments.length === 1) {
        _ref = [obj, this, null], handler = _ref[0], obj = _ref[1], context = _ref[2];
      }
      if (arguments.length === 2) {
        _ref1 = [context, null], handler = _ref1[0], context = _ref1[1];
      }
      isArr = obj instanceof Array;
      list = isArr ? [] : {};
      this.each(obj, context, function(value, key, index) {
        var result;
        result = context ? handler.call(context, value, key, index) : handler(value, key, index);
        if (result !== false) {
          return list[key] = result;
        }
      });
      return list;
    },
    collectEntries: function(obj, context, handler) {
      var list, _ref, _ref1;
      if (arguments.length === 1) {
        _ref = [obj, this, null], handler = _ref[0], obj = _ref[1], context = _ref[2];
      }
      if (arguments.length === 2) {
        _ref1 = [context, null], handler = _ref1[0], context = _ref1[1];
      }
      list = {};
      this.each(obj, context, function(value, key, index) {
        var result;
        result = context ? handler.call(context, value, key, index) : handler(value, key, index);
        if (result !== false) {
          return list[result[0]] = result[1];
        }
      });
      return list;
    },
    repeat: function(num, context, handler) {
      var _ref;
      if (arguments.length === 2) {
        _ref = [context, null], handler = _ref[0], context = _ref[1];
      }
      return this.each((new Array(num)).join(".").split(/.?/), context, function(value, key, index) {
        if (context) {
          return handler.call(context, index);
        } else {
          return handler(index);
        }
      });
    },
    trim: function(string) {
      return string.replace(/^\s*|\s*$/g, '');
    },
    interval: function(delay, handler) {
      return setInterval(handler, delay);
    },
    timeout: function(delay, handler) {
      return setTimeout(handler, delay);
    },
    coord2index: function(width, x, y) {
      return ((y - 1) * width) + (x - 1);
    },
    index2coord: function(width, index) {
      return [(index % width) + 1, (index / width >> 0) + 1];
    },
    instanceOf: function(obj1, obj2) {
      var fnc1, fnc2;
      if (obj1 && obj2) {
        fnc1 = typeof obj1 === "function" ? obj1.prototype.constructor : obj1.constructor;
        fnc2 = typeof obj2 === "function" ? obj2.prototype.constructor : obj2.constructor;
        return fnc1.name === fnc2.name;
      }
    }
  });

}).call(this);
(function() {
  service("CharacterGenerator:LiquidCrystal,Symbols,utils", function(LiquidCrystal, Symbols, utils) {
    var CharacterGenerator;
    return CharacterGenerator = (function() {
      var cursor, letters, lines, liquidCrystal, systemMethods;

      CharacterGenerator.CONTROL_SYMBOL_RESET = "resetCursor";

      CharacterGenerator.CONTROL_SYMBOL_NEWLINE = "newLine";

      CharacterGenerator.CONTROL_SYMBOL_INCREMENT = "increment";

      liquidCrystal = null;

      lines = null;

      letters = null;

      cursor = [0, 0];

      systemMethods = {
        resetCursor: function() {
          return cursor = [0, 0];
        },
        newLine: function() {
          cursor[0] = 0;
          return cursor[1] = (cursor[1] + (liquidCrystal.height / lines)) % liquidCrystal.height;
        },
        increment: function(index) {
          if (index == null) {
            index = liquidCrystal.width / letters;
          }
          if (cursor[0] + index >= liquidCrystal.length) {
            cursor[0] = 0;
            return systemMethods.newLine();
          } else {
            return cursor[0] = cursor[0] + index;
          }
        }
      };

      function CharacterGenerator(lc, _letters, _lines) {
        liquidCrystal = lc;
        lines = _lines;
        letters = _letters;
      }

      CharacterGenerator.prototype.setCursor = function(x, y) {
        return cursor = [x, y];
      };

      CharacterGenerator.prototype.printSymbol = function(symbol) {
        switch (symbol.type) {
          case "control":
            systemMethods[symbol.command]();
            break;
          default:
            utils.each(symbol.mask, this, function(bit, key, index) {
              var coord, x, y;
              if (bit === 1) {
                coord = utils.index2coord(symbol.size, index);
                x = cursor[0] + coord[0];
                y = cursor[1] + coord[1];
                return liquidCrystal.setPixel(x, y);
              }
            });
            systemMethods.increment(symbol.size + 1);
        }
        return void 0;
      };

      return CharacterGenerator;

    })();
  });

}).call(this);
(function() {
  service("Symbols:utils", function(utils) {
    var Binary, ControlSymbol, Hexadecimal;
    return {
      ControlSymbol: ControlSymbol = (function() {
        ControlSymbol.prototype.type = "control";

        function ControlSymbol(command) {
          this.command = command;
        }

        return ControlSymbol;

      })(),
      Binary: Binary = (function() {
        Binary.prototype.type = "char";

        function Binary(size, mask) {
          this.size = size;
          this.mask = mask;
        }

        return Binary;

      })(),
      Hexadecimal: Hexadecimal = (function() {
        var hex2bin;

        Hexadecimal.prototype.type = "char";

        hex2bin = function(size, mask) {
          var normalMask;
          mask = parseInt(mask, 16).toString(2);
          normalMask = new Array((Math.ceil(mask.length / size) * size) + 1).join(0);
          mask = normalMask.replace(new RegExp("\\d{0," + mask.length + "}$"), mask).split(/\0?/);
          return this.mask = utils.collect(mask, function(bit) {
            return +bit;
          });
        };

        function Hexadecimal(size, mask) {
          this.size = size;
          this.mask = hex2bin(this.size, mask);
        }

        return Hexadecimal;

      })()
    };
  });

}).call(this);
(function() {
  service("GraphicGenerator:utils,GraphicObject", function(utils, GraphicObject) {
    var GraphicGenerator;
    return GraphicGenerator = (function() {
      var liquidCrystal;

      liquidCrystal = null;

      function GraphicGenerator(lc) {
        liquidCrystal = lc;
      }

      GraphicGenerator.prototype.render = function(object) {
        var map;
        map = object.render();
        return utils.each(map, function(coord) {
          return liquidCrystal.setPixel(coord[0], coord[1]);
        });
      };

      return GraphicGenerator;

    })();
  });

}).call(this);
(function() {
  service("GraphicObjects:utils", function(utils) {
    var renders;
    renders = {

      /* JUST OBJECT */
      Object: function() {
        return this.map;
      },

      /* LINE OBJECT */
      Line: function() {
        var coords, stepX, stepY, steps;
        coords = [];
        steps = Math.max(Math.abs(this.map[0][0] - this.map[1][0]), Math.abs(this.map[0][1] - this.map[1][1]));
        stepX = (this.map[1][0] - this.map[0][0]) / steps;
        stepY = (this.map[1][1] - this.map[0][1]) / steps;
        coords.push(this.map[0]);
        utils.repeat(steps, function(index) {
          var coord;
          coord = coords[index];
          return coords.push([coord[0] + stepX, coord[1] + stepY]);
        });
        return coords;
      },

      /* CIRCLE OBJECT */
      Circle: function() {
        var R, X, Y, coords, _ref;
        coords = [];
        _ref = this.map, X = _ref[0], Y = _ref[1], R = _ref[2];
        utils.repeat(361, function(angle) {
          return coords.push([X + R * Math.sin(angle + 1), Y + R * Math.cos(angle + 1)]);
        });
        return coords;
      },

      /* JUST 3D OBJECT */
      Object3D: function() {}
    };
    return utils.collect(renders, function(render, name) {
      var GraphicObject;
      return GraphicObject = (function() {
        function GraphicObject(map) {
          this.map = map;
        }

        GraphicObject.prototype.render = render;

        return GraphicObject;

      })();
    });
  });

}).call(this);
(function() {
  service("BasePixel:el", function(el) {
    var BasePixel;
    return BasePixel = (function() {
      var baseStyles;

      function BasePixel() {}

      baseStyles = {
        margin: "1px 0 0 1px",
        "float": "left"
      };

      BasePixel.prototype.make = function() {
        this.el = el.make(this.tagName);
        el.styles(this.el, this.styles.common);
        return el.styles(this.el, baseStyles);
      };

      BasePixel.prototype.active = function(turn) {
        el.styles(this.el, turn === true ? this.styles.active : this.styles.common);
        return el.styles(this.el, baseStyles);
      };

      return BasePixel;

    })();
  });

}).call(this);
(function() {
  service("LiquidCrystal:DefaultPixel,BasePixel,utils,el", function(DefaultPixel, BasePixel, utils, el) {
    var LiquidCrystal;
    return LiquidCrystal = (function() {
      function LiquidCrystal() {}

      LiquidCrystal.prototype = new Array;

      LiquidCrystal.name = "Unnamed";

      LiquidCrystal.address = "javascript:void(0);";

      LiquidCrystal.borderColor = "#000000";

      LiquidCrystal.pixelSize = 1;

      LiquidCrystal.prototype.build = function() {
        return utils.repeat(this.width * this.height, this, function(index) {
          var coord;
          coord = utils.index2coord(this.width, index);
          return this.push(new this.pixel(coord[0], coord[1], this.pixelSize));
        });
      };

      LiquidCrystal.prototype.mount = function(parent) {
        var fragment, vendor;
        el.styles(parent, {
          width: "" + (((this.pixelSize + 1) * this.width) + 1) + "px",
          height: "" + (((this.pixelSize + 1) * this.height) + 21) + "px",
          background: this.backlight,
          borderLeft: "4px solid " + this.borderColor,
          borderRight: "4px solid " + this.borderColor,
          borderBottom: "4px solid " + this.borderColor
        });
        vendor = el.make("a", {
          href: this.address,
          target: "_blank"
        }, this.name, el.make("div", null, null, parent)).parentNode;
        el.styles(vendor, {
          height: "20px",
          background: "" + this.borderColor
        });
        el.styles(vendor.children.item(0), {
          color: "#FFFFFF",
          fontSize: "12px",
          fontFamily: "sans-serif",
          textDecoration: "none"
        });
        fragment = document.createDocumentFragment();
        utils.each(this, function(pixel) {
          if (utils.instanceOf(pixel, BasePixel)) {
            return fragment.appendChild(pixel.el);
          }
        });
        return parent.appendChild(fragment);
      };

      LiquidCrystal.prototype.clear = function() {
        return utils.each(this, function(pixel) {
          return pixel.active(false);
        });
      };

      LiquidCrystal.prototype.round = function(num) {
        return Math.round(num);
      };

      LiquidCrystal.prototype.setPixel = function(x, y) {
        return this.setIndex(utils.coord2index(this.width, this.round(x), this.round(y)));
      };

      LiquidCrystal.prototype.setIndex = function(index) {
        if (index in this) {
          return this[index].active(true);
        }
      };

      return LiquidCrystal;

    })();
  });

}).call(this);
(function() {
  service("MT16S2H2FLA:LiquidCrystal,MT16S2H2FLA_PIXEL", function(LiquidCrystal, MT16S2H2FLA_PIXEL) {
    var MT16S2H2FLA;
    return MT16S2H2FLA = (function() {
      MT16S2H2FLA.prototype = new LiquidCrystal;

      MT16S2H2FLA.prototype.name = "МЭЛТ MT-16S2H-2FLA";

      MT16S2H2FLA.prototype.address = "http://www.melt.com.ru/index.php?page=shop.product_details&product_id=6506&Itemid=6";

      MT16S2H2FLA.prototype.borderColor = "#555555";

      MT16S2H2FLA.prototype.width = 80;

      MT16S2H2FLA.prototype.height = 16;

      MT16S2H2FLA.prototype.pixelSize = 8;

      MT16S2H2FLA.prototype.backlight = "#FED04B";

      MT16S2H2FLA.prototype.pixel = MT16S2H2FLA_PIXEL;

      function MT16S2H2FLA(canvas) {
        this.build();
        this.mount(canvas);
      }

      return MT16S2H2FLA;

    })();
  });

}).call(this);
(function() {
  service("MT16S2H2FLA_PIXEL:el,BasePixel", function(el, BasePixel) {
    var MT16S2H2FLA_PIXEL;
    return MT16S2H2FLA_PIXEL = (function() {
      MT16S2H2FLA_PIXEL.prototype = new BasePixel;

      MT16S2H2FLA_PIXEL.prototype.tagName = "div";

      MT16S2H2FLA_PIXEL.prototype.styles = {
        common: {
          width: "4px",
          height: "4px",
          opacity: ".1",
          background: "#444444"
        },
        active: {
          opacity: ".9"
        }
      };

      function MT16S2H2FLA_PIXEL(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.styles.common.width = "" + this.size + "px";
        this.styles.common.height = "" + this.size + "px";
        this.make();
      }

      return MT16S2H2FLA_PIXEL;

    })();
  });

}).call(this);
(function() {
  service("Game:utils,GraphicGenerator,CharacterGenerator,Symbols", function(utils, GraphicGenerator, CharacterGenerator, Symbols) {
    var Game;
    return Game = (function() {
      var characterGenerator, graphicGenerator, init, liquidCrystal, render, renderEntity, renderHealth, renderWalls, start, state, stop, symbols, testMove, timers, walls;

      liquidCrystal = null;

      graphicGenerator = null;

      characterGenerator = null;

      walls = [];

      state = {
        entity: [2, 2],
        vector: [1, 0],
        blink: 1,
        blinkLiveFreq: 2,
        blinkDeadFreq: 6,
        health: 100
      };

      renderWalls = function() {
        return utils.each(walls, function(wall) {
          return graphicGenerator.render(wall);
        });
      };

      renderEntity = function() {
        if (++state.blink % (state.health ? state.blinkLiveFreq : state.blinkDeadFreq)) {
          return liquidCrystal.setPixel.apply(liquidCrystal, state.entity);
        }
      };

      renderHealth = function() {
        characterGenerator.setCursor(51, 1);
        characterGenerator.printSymbol(symbols.h);
        characterGenerator.printSymbol(symbols.colon);
        return String(state.health).replace(/\d/g, function(num) {
          return characterGenerator.printSymbol(symbols["dec" + num]);
        });
      };

      render = function() {
        liquidCrystal.clear();
        renderWalls();
        renderEntity();
        return renderHealth();
      };

      start = function() {
        return utils.collect(timers, function(params) {
          if (params.timer) {
            clearInterval(params.timer);
          }
          params.timer = setInterval(params.handler, params.interval);
          return params;
        });
      };

      stop = function() {
        return utils.collect(timers, function(params) {
          if (params.timer) {
            params.timer = clearInterval(params.timer);
          }
          return params;
        });
      };

      init = function() {
        return utils.each(state, function(value, name) {
          if (name.substr(0, 1) !== "_") {
            return state["_" + name] = value;
          }
        });
      };

      testMove = function(x, y) {
        var result;
        result = true;
        if ((x <= 0 || x >= liquidCrystal.width) || (y <= 0 || y >= liquidCrystal.height)) {
          result = false;
        } else {
          utils.each(walls, function(wall) {
            return utils.each(wall.render(), function(coords) {
              if (coords[0] === x && coords[1] === y) {
                return result = false;
              }
            });
          });
        }
        return result;
      };

      timers = {
        live: {
          interval: 10000,
          handler: function() {
            if (state.health) {
              return state.health--;
            }
          }
        },
        render: {
          interval: 100,
          handler: render
        },
        move: {
          interval: 500,
          handler: function() {
            var x, y, _ref;
            if (state.health) {
              _ref = state.entity, x = _ref[0], y = _ref[1];
              if (testMove(x + state.vector[0], y + state.vector[1])) {
                return state.entity = [x + state.vector[0], y + state.vector[1]];
              }
            }
          }
        },
        vector: {
          interval: 5000,
          handler: function() {
            var dirs;
            dirs = [-1, 0, 1];
            return state.vector = [dirs[Math.random() * 3 >> 0], dirs[Math.random() * 3 >> 0]];
          }
        }
      };

      symbols = {
        h: new Symbols.Hexadecimal(4, "99f99"),
        colon: new Symbols.Hexadecimal(1, "12"),
        dec0: new Symbols.Hexadecimal(4, "69bd6"),
        dec1: new Symbols.Hexadecimal(3, "1749"),
        dec2: new Symbols.Hexadecimal(4, "f9f8f"),
        dec3: new Symbols.Hexadecimal(4, "f1f1f"),
        dec4: new Symbols.Hexadecimal(4, "99f11"),
        dec5: new Symbols.Hexadecimal(4, "f8f1f"),
        dec6: new Symbols.Hexadecimal(4, "f1f9f"),
        dec7: new Symbols.Hexadecimal(3, "72c9"),
        dec8: new Symbols.Hexadecimal(4, "f9f9f"),
        dec9: new Symbols.Hexadecimal(4, "f9f1f")
      };

      function Game(lc) {
        liquidCrystal = lc;
        graphicGenerator = new GraphicGenerator(lc);
        characterGenerator = new CharacterGenerator(lc, 20, 2);
      }

      Game.prototype.addWall = function(object) {
        return walls.push(object);
      };

      Game.prototype.init = function() {
        init();
        return true;
      };

      Game.prototype.start = function() {
        start();
        return true;
      };

      Game.prototype.stop = function() {
        stop();
        return true;
      };

      return Game;

    })();
  });

}).call(this);
